/**
 * Helper methods for storing sensor readings in
 * Google Spreadsheets data source.
 */
var UA_SheetsSource = {
  /**
   * Creates a function to store data in a Google Spreadsheet
   *
   * Used as a paramter for the function processStarredThreads
   *
   * @param {Sheet} A Google Spreadsheet Sheet
   * @return {Function} A function to store data in a Google Spreadsheet
   */
  newInsertRowAdapter: function(sheet)
  {
    var active_sheet = sheet.setActiveSheet(sheet.getSheets()[0]);
    return function(sensor_id, timestamp, distance, temperature) {
      sheet.appendRow([sensor_id, timestamp, distance, temperature]);
    };
  }
};


/**
 * Helper methods for storing sensor readings in
 * Google Fusion Tables data source.
 */
var UA_FusionTableSource = {
  SCHEMA: [
    ["SensorID", "STRING"],
    ["Timestamp", "NUMBER"],
    ["Distance", "NUMBER"],
    ["Temperature", "NUMBER"],
  ],

  /**
   * Gets list of column names from schema
   *
   * @return {Array} List of column names
   */
  getColumns: function()
  {
    var cols = [];
    for (var i = 0; i < this.SCHEMA.length; ++i)
    {
       cols.push(this.SCHEMA[i][0]);
    }
    return cols;
  },

  /**
   * Creates Fusion table with correct schema
   *
   * @param {string} Name of the Fusion table
   * @return {Table} New FusionTable table
   */
  create: function(name)
  {
    var cols = [];
    for (var i = 0; i < this.SCHEMA.length; ++i)
    {
      var col = FusionTables.newColumn();
      col.columnId = i;
      col.name = this.SCHEMA[i][0];
      col.type = this.SCHEMA[i][1];
      cols.push(col);
    }

    var table = FusionTables.newTable();
    table.name = name;
    table.columns = cols;
    table.isExportable = true;
    var result = JSON.parse(FusionTables.Table.insert(table));
    table.tableId = result.tableId;

    return table;
  },

  /**
   * Creates a function to store data in a Fusion table.
   *
   * Used as a paramter for the function processStarredThreads
   *
   * @param {Table} Fusion table
   * @return {Function} A function to store data in a Fusion table
   */
  newInsertRowAdapter: function(table)
  {
    var col_names = this.getColumns().join(',');
    return function(sensor_id, timestamp, distance, temperature) {
      var data = ['"' + sensor_id + '"', timestamp, distance, temperature].join(',');
      var sql = 'INSERT INTO ' + table.tableId + ' ( ' + col_names + ' ) VALUES(' + data + ')';
      FusionTables.Query.sql(sql);
    };
  }
};


/**
 * Parses sensor id from email subject
 *
 * Assumes that the subject format will be like - "SMS from (222) 333-4444"
 *
 * @param {string} Email subject
 * @return {string} Phone number of sensor in international format
 */
function getSensorIdFromSubject(subject)
{
  var length = subject.length;
  var sensor_id = "+1";
  for (var i = 0; i < length; ++i)
  {
    if (isNaN(subject[i]) === false && subject[i] != " ") {
        sensor_id += subject[i];
    }
  }
  return sensor_id;
}


/**
 * Gets starred messages from Gmail and extracts sensor readings from SMS emails
 * forwarded from Google Voice.
 *
 * Notes:
 *
 * - Gmail throttles the script if too many actions are taken (ie, fetch/read/star/unstar msgs)
 *   Should not be a problem at a rate of one email every five hours.
 * - Ideally there should be a way to prevent cases where a message is processed
 *   but not unstarred due to a Gmail error. This would lead to a message being processed twice.
 *   However the probability of that happening is very low so long as you are not processing
 *   greater than 100 messages, in which case Gmail will throttle the script or AppScript max execution
 *   time will be reached.
 *
 * @param {function} Callback that expects four parameters: sensor_id, timestamp, temperature, distance
 * @return {string} Phone number of sensor in international format
 */
function processStarredThreads(insertRow)
{
  var threads = GmailApp.getStarredThreads();

  for (var t in threads)
  {
    var thread = threads[t];
    var subject = thread.getFirstMessageSubject();
    var msgs = thread.getMessages();
    var msg_count = thread.getMessageCount();

    // Only process messages from Google Voice
    if (subject.indexOf('SMS from') === 0 && msg_count > 0)
    {

      var sensor_id = getSensorIdFromSubject(subject);

      // Loop through thread of messages. Each thread contains messages
      // from a single sensor up to 100 messages.
      for (var i = 0; i < msg_count; ++i) {

        // Starred messages have not been processed yet
        if (msgs[i].isStarred()) {

          // Get the body text from the email message.
          var text = msgs[i].getPlainBody();

          // Break the message into separate lines
          // The emails seem to add an automatic line
          // break at about 73-75 characters.
          var lines = text.split("\r\n");
          var data = "";

          // The data we need will be on 2-3 lines if
          // we maxed out most of the text message length.
          //
          // Hence we need to combine the lines again.
          for (var j = 0; j < lines.length; ++j)
          {
            if (lines[j].length > 0)
            {
              data += lines[j];
            } else
            {
              break;
            }
          }

          // For some reason a double space is present in the
          // recombined message data. This extra space occurs exactly
          // at the line break.
          //
          // Here we split the sensor readings into individual
          // readings of - timestamp distance temperature.
          data = data.trim().replace("  ", " ").split(';');

          var readings = [];
          for (var j = 0; j < data.length; ++j)
          {
            readings.push(data[j].split(' '));
          }

          // The first timestamp should be a full unix timestamp.
          // We will need this to calculate the other timestamps.
          // The other timestamps consist of minutes after the first
          // reading in the message.
          var startTime = parseInt(readings[0][0]);

          insertRow(sensor_id, startTime, readings[0][1], readings[0][2]);
          for (var j = 1; j < readings.length; ++j)
          {
            insertRow(
              sensor_id,
              startTime + (60 * parseInt(readings[j][0])),
              readings[j][1],
              readings[j][2]
            );
          }

          // Unstar the message now that we've added the reading to the Sheet.
          msgs[i].unstar();
        }

        // Every fifteen readings, let's pause for one second.
        // Not sure if this helps avoid the Gmail throttling though.
        if (i % 15 == 0)
        {
          Utilities.sleep(1000);
        }
      }
    }
  }
}


/**
 * Main program to store sensor readings into Google Fusion Tables
 */
function main_processWithFusionTables()
{
  var script_properties = PropertiesService.getScriptProperties();
  var user_properties = PropertiesService.getUserProperties();

  var table_id = user_properties.getProperty('TABLE_ID');
  var table = null;

  try
  {
    if (table_id)
    {
      table = FusionTables.Table.get(table_id);
    }
    else
    {
      throw new "Table ID is undefined";
    }
  }
  catch(e)
  {
    table = UA_FusionTableSource.create(script_properties.getProperty('DEFAULT_NAME'));
    user_properties.setProperty('TABLE_ID', table.tableId);
  }

  var insertRow = UA_FusionTableSource.newInsertRowAdapter(table);

  processStarredThreads(insertRow);
}


/**
 * Main program to store sensor readings into Google Spreadsheets
 */
function main_processWithSheets()
{
  var script_properties = PropertiesService.getScriptProperties();
  var user_properties = PropertiesService.getUserProperties();

  var sheet_url = user_properties.getProperty('SHEET_URL');
  var sheet = null;

  try
  {
    sheet = SpreadsheetApp.openByUrl(sheet_url);
  }
  catch(e)
  {
    sheet = SpreadsheetApp.create(script_properties.getProperty('DEFAULT_NAME'));
    user_properties.setProperty('SHEET_URL', sheet.getUrl());
  }

  var insertRow = UA_SheetsSource.newInsertRowAdapter(sheet);
  processStarredThreads(insertRow);
}